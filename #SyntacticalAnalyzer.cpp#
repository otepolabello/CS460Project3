#include <iostream>
#include <iomanip>
#include <fstream>
#include <cstdlib>
#include "SyntacticalAnalyzer.h"

using namespace std;

SyntacticalAnalyzer::SyntacticalAnalyzer (char * filename)
{
    string name = filename;
    // declaring our new objects. (Lex Analyzer & Code Generator)
    lex = new LexicalAnalyzer (filename);
    gen = new CodeGen (filename);
//    string p2name = name.substr (0, name.length()-3) + ".p2";
    //HERE//
    fileTitle = name.substr (0, name.length()-3);
//    p2file.open(p2name);
    //HERE//
    p2file.open(fileTitle + ".p2");
    //HERE//
    //Setting up token and running 
    token_type t;
    t = lex->GetToken();
    int errors = program();
}

SyntacticalAnalyzer::~SyntacticalAnalyzer ()
{
    p2file.close();
    delete lex;
    delete gen;
}

int SyntacticalAnalyzer::program()
{
    int errors = 0;
    string tok = lex->GetTokenName(token), lexeme = lex->GetLexeme();
    p2file << "Entering Program function; current token is: " << tok << ", lexeme: " << lexeme << endl;
    // apply rule 1
    if (token == LPAREN_T)
    {
        p2file << "Using Rule 1\n";
        token = lex->GetToken();
        errors += define();
        if (token == LPAREN_T)
        {
            token = lex->GetToken();
            errors += more_defines();
        }
        else
        {
            lex->ReportError ("left parenthesis expected, '" + lex->GetTokenName(token) + "' found.");
            errors++;
        }
        if (token == EOF_T)
        {
            // do nothing
        }
        else
        {
            lex->ReportError ("EOF token expected, '" + lex->GetTokenName(token) + "' found.");
            errors++;
        }
    }
    else
    {
        lex->ReportError ("left parenthesis expected, '" + lex->GetTokenName(token) + "' found.");
        errors++;
    }
    codeGen->WriteCode(1,"return 0;\n");
    codeGen->WriteCode(0, "}");
    tok = lex->GetTokenName(token);
    p2file << "Exiting Program function; current token is: " << tok << endl;
    return errors;
}

int SyntacticalAnalyzer::more_defines()
{
    string tok = lex->GetTokenName(token), lexeme = lex->GetLexeme();
    p2file << "Entering More_Defines function; current token is: " << tok << ", lexeme: " << lexeme << endl;
    int errors = 0;
    if (token == DEFINE_T)
    {   // apply rule 2
        p2file << "Using Rule 2\n";
        //HERE//
        code->WriteCode(0, "Object(");
        //HERE//
        errors += define();
        if (token == LPAREN_T)
        {
            token = lex->GetToken();
            errors += more_defines();
        }
        else
        {
            lex->ReportError ("left parenthesis expected, '" + lex->GetTokenName(token) + "' found.");
            errors++;
        }
    }
    else if (token == IDENT_T)
    {   // apply rule 3
        p2file << "Using Rule 3\n";
        //HERE//
        code->WriteCode(0, lex->GetLexeme());
        //HERE//
        token = lex->GetToken();
        errors += stmt_list();
        if (token == RPAREN_T)
            token = lex->GetToken();
        else
        {
            lex->ReportError ("right parenthesis expected, '" + lex->GetTokenName(token) + "' found.");
            errors++;
        }
    }

    if (token == EOF_T)
    {   // apply rule 1
    }
    else
    {
        lex->ReportError ("IDENT_T or DEFINE_T expected, '" + lex->GetTokenName(token) + "' found.");
        errors++;
    }
    tok = lex->GetTokenName(token);
    p2file << "Exiting More_Defines function; current token is: " << tok << endl;
    return errors;
}

int SyntacticalAnalyzer::define()
{
    string tok = lex->GetTokenName(token), lexeme = lex->GetLexeme();
    p2file << "Entering Define function; current token is: " << tok << ", lexeme: " << lexeme << endl;
    int errors = 0;
    if (token == DEFINE_T)
    {   // apply rule 4
        p2file << "Using Rule 4\n";
        token = lex->GetToken();
        if (token == LPAREN_T)
        {
            token = lex->GetToken();
            if (token == IDENT_T)
            {
                token = lex->GetToken();
                errors += param_list();
                if(lexeme == "main"){
                  codeGen->(0, "int main(");
                  token = lex->GetToken();
                } else {
                  CodeGen->WriteCode(0, "object " + lexeme + "(");
                  token = lex-GetToken();
                }
                if (token == RPAREN_T)
                {
                    token = lex->GetToken();
                    codeGen->(0, ")\n{\n");
                    errors += stmt();
                    errors += stmt_list();
                    if (token == RPAREN_T)
                        token = lex->GetToken();
                    else
                    {
                        lex->ReportError ("right parenthesis expected, '" + lex->GetTokenName(token) + "' found.");
                        errors++;
                    }
                }
                else
                {
                    lex->ReportError ("right parenthesis expected, '" + lex->GetTokenName(token) + "' found.");
                    errors++;
                }
            }
            else
            {
                lex->ReportError ("IDENT_T token expected, '" + lex->GetTokenName(token) + "' found.");
                errors++;
            }
        }
        else
        {
            lex->ReportError ("left parenthesis expected, '" + lex->GetTokenName(token) + "' found.");
            errors++;
        }
    }
    else
    {
        lex->ReportError ("DEFINE_T token expected, '" + lex->GetTokenName(token) + "' found.");
        errors++;
    }
    tok = lex->GetTokenName(token);
    p2file << "Exiting Define function; current token is: " << tok << endl;
    return errors;
}

int SyntacticalAnalyzer::stmt_list()
{
    string tok = lex->GetTokenName(token), lexeme = lex->GetLexeme();
    p2file << "Entering Stmt_List function; current token is: " << tok << ", lexeme: " << lexeme << endl;
    int errors = 0;
    if (token == NUMLIT_T || token == STRLIT_T || token == SQUOTE_T
        || token == IDENT_T || token == LPAREN_T)
    {   // apply rule 5
        p2file << "Using Rule 5\n";
        errors += stmt();
        errors += stmt_list();
    }
    else if (token == RPAREN_T)
    {   // apply rule 6
        p2file << "Using Rule 6\n";
    }
    else
    {
        lex->ReportError ("right parenthesis expected, '" + lex->GetTokenName(token) + "' found.");
        errors++;
    }
    tok = lex->GetTokenName(token);
    p2file << "Exiting Stmt_List function; current token is: " << tok << endl;
    return errors;
}

int SyntacticalAnalyzer::stmt()
{
    string tok = lex->GetTokenName(token), lexeme = lex->GetLexeme();
    p2file << "Entering Stmt function; current token is: " << tok << ", lexeme: " << lexeme << endl;
    int errors = 0;
    if (token == NUMLIT_T || token == STRLIT_T || token == SQUOTE_T)
    {   // apply rule 7
        p2file << "Using Rule 7\n";
        errors += literal();
    }
    else if (token == IDENT_T)
    {   // apply rule 8
        p2file << "Using Rule 8\n";
        token = lex->GetToken();
    }
    else if (token == LPAREN_T)
    {   // apply rule 9
        p2file << "Using Rule 9\n";
        token = lex->GetToken();
        errors += action();
        if (token == RPAREN_T)
            token = lex->GetToken();
        else
        {
            lex->ReportError ("right parenthesis expected, '" + lex->GetTokenName(token) + "' found.");
            errors++;
        }
    }
    else
    {
        lex->ReportError ("NUMLIT_T, STRLIT_T, SQUOTE_T, IDENT_T, or LPAREN_T expected, '" + lex->GetTokenName(token) + "' found.");
        errors++;
    }
    tok = lex->GetTokenName(token);
    p2file << "Exiting Stmt function; current token is: " << tok << endl;
    return errors;
}

int SyntacticalAnalyzer::literal()
{
    string tok = lex->GetTokenName(token), lexeme = lex->GetLexeme();
    p2file << "Entering Literal function; current token is: " << tok << ", lexeme: " << lexeme << endl;
    int errors = 0;
    if (token == NUMLIT_T)
    {   // apply rule 10
        p2file << "Using Rule 10\n";
	gen->WriteCode(0, "()" + lex->GetLexeme() + ")");
        token = lex->GetToken();
    }
   
    else if (token == STRLIT_T)
    {   // apply rule 11
        p2file << "Using Rule 11\n";
	gen->WriteCode(0, lex->GetLexeme());
        token = lex->GetToken();
    }
    else if (token == SQUOTE_T)
    {   // apply rule 12
        p2file << "Using Rule 12\n";
        token = lex ->GetToken();
        errors += quoted_lit();
    }
    else
    {
        lex->ReportError ("NUMLIT_T, STRLIT_T or SQUOTE_T expected, '" + lex->GetTokenName(token) + "' found.");
        errors++;
    }
    tok = lex->GetTokenName(token);
    p2file << "Exiting Literal function; current token is: " << tok << endl;
    return errors;
}

int SyntacticalAnalyzer::quoted_lit()
{
    string tok = lex->GetTokenName(token), lexeme = lex->GetLexeme();
    p2file << "Entering Quoted_Lit function; current token is: " << tok << ", lexeme: " << lexeme << endl;
    int errors = 0;
    if (token >= IDENT_T && token <= LPAREN_T || token == SQUOTE_T)
    {   // apply rule 13
        p2file << "Using Rule 13\n";
        errors += any_other_token();
    }
    else
    {
        lex->ReportError ("any other token expected, '" + lex->GetTokenName(token) + "' found.");
        errors++;
    }
    tok = lex->GetTokenName(token);
    p2file << "Exiting Quoted_Lit function; current token is: " << tok << endl;
    return errors;
}

int SyntacticalAnalyzer::more_tokens()
{
    string tok = lex->GetTokenName(token), lexeme = lex->GetLexeme();
    p2file << "Entering More_Tokens function; current token is: " << tok << ", lexeme: " << lexeme << endl;
    int errors = 0;
    if (token >= IDENT_T && token <= LPAREN_T || token == SQUOTE_T)
    {   // apply rule 14
        p2file << "Using Rule 14\n";
        errors += any_other_token();
        errors += more_tokens();
    }
    else if (token == RPAREN_T)
    {   // apply rule 15
        p2file << "Using Rule 15\n";
    }
    else
    {
        lex->ReportError ("any other token expected, '" + lex->GetTokenName(token) + "' found.");
        errors++;
    }
    tok = lex->GetTokenName(token);
    p2file << "Exiting More_Tokens function; current token is: " << tok << endl;
    return errors;
}

int SyntacticalAnalyzer::param_list()
{
    string tok = lex->GetTokenName(token), lexeme = lex->GetLexeme();
    p2file << "Entering Param_List function; current token is: " << tok << ", lexeme: " << lexeme << endl;
    int errors = 0;
    if (token == IDENT_T)
    {   // apply rule 16
      codeGen->WriteCode(0, lexeme + " ")
        p2file << "Using Rule 16\n";
        token = lex->GetToken();
        errors += param_list();
    }
    else if (token == RPAREN_T)
    {   // apply rule 17
        p2file << "Using Rule 17\n";
    }
    else
    {
        lex->ReportError ("right parenthesis expected, '" + lex->GetTokenName(token) + "' found.");
        errors++;
    }
    tok = lex->GetTokenName(token);
    p2file << "Exiting Param_List function; current token is: " << tok << endl;
    return errors;
}

int SyntacticalAnalyzer::else_part()
{
    string tok = lex->GetTokenName(token), lexeme = lex->GetLexeme();
    p2file << "Entering Else_Part function; current token is: " << tok << ", lexeme: " << lexeme << endl;
    int errors = 0;
    if (token == NUMLIT_T || token == STRLIT_T || token == SQUOTE_T
        || token == IDENT_T || token == LPAREN_T)
    {   // apply rule 18
        p2file << "Using Rule 18\n";
        errors += stmt();
    }
    else if (token == RPAREN_T)
    {   // apply rule 19
        p2file << "Using Rule 19\n";
    }
    else
    {
        lex->ReportError ("right parenthesis expected, '" + lex->GetTokenName(token) + "' found.");
        errors++;
    }
    tok = lex->GetTokenName(token);
    p2file << "Exiting Else_Part function; current token is: " << tok << endl;
    return errors;
}

int SyntacticalAnalyzer::stmt_pair()
{
    string tok = lex->GetTokenName(token), lexeme = lex->GetLexeme();
    p2file << "Entering Stmt_Pair function; current token is: " << tok << ", lexeme: " << lexeme << endl;
    int errors = 0;
    if (token == LPAREN_T)
    { 